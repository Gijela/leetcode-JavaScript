# 哈希表

实现方法：数组、set、map

## (数组)242.有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

示例 1:  
输入: s = "rat", t = "car"  
输出: false

![242.有效的字母异位词](https://tva1.sinaimg.cn/large/008eGmZEly1govxyg83bng30ds09ob29.gif)

ps: 将字母顺序和数组下标的顺序联系即可。  
数组下标 = x.charCodeAt() - 'a'.charCodeAt()

## (数组)1002. 查找常用字符

给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ 包括重复字符），并以数组形式返回。你可以按 任意顺序 返回答案。

示例 1：

输入：words = ["bella","label","roller"]  
输出：["e","l","l"]

![1002.查找常用字符](https://code-thinking.cdn.bcebos.com/pics/1002.查找常用字符.png)

ps： 很耗空间，没有什么好方法

## (set)349. 两个数组的交集

题意：给定两个数组，编写一个函数来计算它们的交集。

![349. 两个数组的交集](https://img-blog.csdnimg.cn/20200818193523911.png)

基本思路：  
将长数组作为对照数组，并去重，如果短数组中的元素在长数组中也有，那么就是交集的元素，添加到结果数组即可。

![set哈希法](https://img-blog.csdnimg.cn/2020080918570417.png)

## (set)第 202 题. 快乐数

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为   1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。

**示例：**

输入：19  
输出：true  
解释：  
1^2 + 9^2 = 82  
8^2 + 2^2 = 68  
6^2 + 8^2 = 100  
1^2 + 0^2 + 0^2 = 1

思路:  
**无限循环**，那么也就是说**求和的过程中，sum 会重复出现**.  
使用 set 哈希法，来判断这个 sum 是否重复出现，如果重复了就是 return false， 否则一直找到 sum 为 1 为止, 如果到最后都找不到 sum == 1, 就返回 false

## (map)1.两数之和

给定一个整数数组 nums  和一个目标值 target，请你在该数组中找出和为目标值的那   两个   整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

**示例:**

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]

解题思路:  
![](https://code-thinking.cdn.bcebos.com/gifs/1.两数之和.gif)

## (map)454.四数相加 II

给定四个包含整数的数组列表  A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得  A[i] + B[j] + C[k] + D[l] = 0。

**例如:**

输入:  
A = [ 1, 2]  
B = [-2,-1]  
C = [-1, 2]  
D = [ 0, 2]  
输出:  
2  
**解释:**  
两个元组如下:

1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0

思路:

1. 首先定义 一个 unordered_map，key 放 a 和 b 两数之和，value 放 a 和 b 两数之和出现的次数。
2. 遍历大 A 和大 B 数组，统计两个数组元素之和，和出现的次数，放到 map 中。
3. 定义 int 变量 count，用来统计 a+b+c+d = 0 出现的次数。
4. 在遍历大 C 和大 D 数组，找到如果 0-(c+d) 在 map 中出现过的话，就用 count 把 map 中 key 对应的 value 也就是出现次数统计出来。
5. 最后返回统计值 count 就可以了

## (map)383. 赎金信

给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)

**注意：**

你可以假设两个字符串均只含有小写字母。

canConstruct("a", "b") -> false  
canConstruct("aa", "ab") -> false  
canConstruct("aa", "aab") -> true

解题步骤：  
![](https://api2.mubu.com/v3/document_image/2f410dda-9ce1-45a4-9673-16618fb72189-11752736.jpg)
